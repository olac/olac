#summary Describe a framework for developing freestanding web pages for OLAC.

= Introduction =

Many OLAC pages are vulnerable to database server outage because they are dynamically generated from data that is dynamically read from the server. They also require more advanced web server configuration, e.g. PHP, CGI, WSGI, MySQL, etc.

OLAC data is not completely static, but it is close to static. The data is updated at most once a day. Thus, by going dynamic, we gain little while suffering from the issues.

In order to avoid the issues, the data needed for web pages is queried and stored on disk as files. This can be done on a regular-basis or whenever there is an update to the database. Then a thin layer of web data API is defined over the data files. Finally, DHTML web pages access the static data using the API via XMLHttpRequest.

(How is this better than generating static HTML directly off the database?)

= Overview =

The following diagram shows how the data stored in the database server flows to the client stating from OLAC DB, a MySQL database.

{{{
              OLAC DB
                 |
                 | Data scripts
                 |
         Static data files
                 |
                 |
                 |
              PyWebAPI
               |    |
               |    |
          ,----'    `-----------.
          |                     |
          |                     | JSON scripts
          |                     |
       srv.wsgi         Static JSON files
}}}

 * OLAC DB - data stored on a database server
 * Static data files - tab delimited tables, XML files, etc. computed from OLAC DB
 * Static JSON files - pieces of information computed from the static data files and represented in JSON

 * Data scripts - read data from OLAC DB and produce static data files
 * PyWebAPI - Python API over the static data files
 * srv.wsgi - exposes PyWebAPI for web clients
 * JSON scripts - for each PyWebAPI function, for every possible input to the function, call the function and save the return value as a file


= Data scripts =

Data scripts are responsible for transforming data stored in OLAC DB into data files such as tab-delimited tables and XML files. The data files are static in the sense that they are not dynamically computed to serve real time HTTP requests. The computation usually consists of series of SQL queries and it is done offline in advance.

Each data file is configured with two configuration variables: data/VARNAME and data/VARNAME.script. The value of data/VARNAME is the location of the data file. The value of VARNAME.script is the location of a data script that generates the data file.

Here is an example. The config variable data/coverage contains the location of a data table need for the [http://www.language-archives.org/documents/coverage.html coverage page].

{{{
$ olacvar data/coverage
/olac/data/coverage/coverage.tab
}}}

The config variable data/coverage.script contains the location of the corresponding data script.

{{{
$ olacvar data/coverage.script
/olac/pkg/DataScripts/Current/generate_coverage_table.py
}}}

Therefore, the coverage table can be generated as follow.

{{{
$ $(olacvar data/coverage.script) > $(olacvar data/coverage)
}}}

As in this example, each data script is responsible for one and only one data file. It takes no input, and output is dumped on standard output.


= PyWebAPI =

PyWebAPI is a collection of Python modules and functions for OLAC. It is intended for a web API, but it can be imported and used by normal Python programs. The configuration variable pywebapi contains the location of the modules.

{{{
$ olacvar pywebapi
/olac/pkg/PyWebAPI/Current/
$ ls $(olacvar pywebapi)
coverage.py
coverage.pyc
...
$ cat $(olacvar pywebapi)/coverage.py
...
def getTable(*args, **kwargs):
    """
    @return: Combined table.
    """
    tabfile = olac.olacvar('data/coverage')
    f = open(tabfile)
    f.readline()
    L = [l.rstrip("\r\n").split('\t') for l in f]
    return json.dumps(L)
...
}}}

Note that PyWebAPI functions take variable number of positional arguments and variable number of keyword arguments although they might not use the arguments. For example, getTable function shown above doesn't use any arguments.

Each PyWebAPI function can be mapped to a URL. For instance, the getTable function above can be mapped to a URL like http://www.language-archives.org/.../coverage/getTable. This topic will be discussed more in srv.wsgi and JSON scripts sections.


= srv.wsgi =

This is a WSGI script that processes any URL beginning with /srv, e.g. http://www.language-archives.org/srv/coverage/getTable. By doing so, it makes PyWebAPI functions available to AJAX applications.

The path component following /srv is mapped a PyWebAPI function. For example, if /coverage/getTable follows /srv, the search will return the getTable function inside the coverage.py module.

The mapping algorithm works as follows. Let the tailing part of the URL following /srv be

{{{
/c1/c2/.../cN?k1=v1&...&kN=vN
}}}

Function (callable) cK is searched using the following search order:

{{{
__init__.py: callable c1
c1/__init__.py: callable c2
c1.py: callable c2
c2/__init__.py: callable c3
c2.py: callable c3
...
cN-1/__init__.py: callable cN
cN-1.py: callable cN
}}}

If found, function cK is called with (cK+1, ..., cN) as positional arguments and {k1=v1, ..., kN=vN} as keyword arguments. The result is transformed into a JSON string and returned.

If no such function is found, HTTP response "404 Not Found" is returned.

For example, the following URL:

{{{
http://www.language-archives.org/srv/nitems/byCountryCode/US
}}}

returns the number of archived items whose country code is US.
