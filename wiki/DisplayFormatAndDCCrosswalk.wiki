#summary Display format and DC crosswalk

=Display format and DC crosswalk=

A number of things need to be fixed:
 * NOTE/olac_display (still in Draft) does not match what is currently implemented, nor is it what we really want
 * The display format in our /item/id static pages differs significantly from the display format generated by the XSL script for the Sample Record
 * The oai_dc records we currently generate from OLACA have extraneous [ ] in them and don't always follow DC best practice (which means we aren't being harvested by OAI aggregation services)

There are three inter-related issues:
 * What is our spec for the OLAC to OAI_DC crosswalk?
 * What do want our displays on the /item/id pages and the Sample Record pages to look like?
 * Do we still need an olac_display format, and if so, what is its spec?

==1. OLAC to OAI_DC crosswalk==

OLAC static repositories contain records in "olac" format only. It is a service of OLACA to implement an OLAC to OAI_DC crosswalk so that these records can be harvested in "oai_dc" format by the OAI world.

The standard Qualified DC to Simple DC "dumb down" algorithm is:
 * Translate dcterms elements (e.g. refinements) to their generic dc equivalent.
 * Drop all attributes in the element tag (e.g. xsi:type for schemes and xml:lang)

The OLAC metadata format adds another attribute, olac:code, to hold the value for one of our community-specific vocabularies. This is essential information that cannot be simply thrown away in a dumb down process. Thus, our crosswalk needs to augment the above rules to specify what to do with each instance of olac:code. There are five uses:

 * Code for Discourse Types `[olac:discourse-type]`
 * Code for Identifying Languages `[olac:language]`
 * Code for Linguistic Field `[olac:linguistic-field]`
 * Code for Linguistic Data Types `[olac:linguistic-type]`
 * Code for Participant Roles `[olac:role]`

_olac:discourse-type._ From the standpoint of the cataloging community in general, this information is more like a description than a type. Thus our mapping for simple DC will be:
 * Generate a `<dc:description>` element which contains "Discourse type:" followed by the code value (with underscores converted to spaces). If the original OLAC `<dc:type>` element has content, simply ignore it. (In all cases to date, it only duplicates the code value; we will advise against using the content.)

_olac:linguistic-field._ Do all of the following that apply:
 * Generate a `<dc:subject>` element in which the code value is the content (with underscores converted to spaces).
 * If the original OLAC `<dc:subject>` element has content, generate another `<dc:subject>` element with that content.

_olac:linguistic-type._ Do the following:
 * Generate a `<dc:type>` element which contains "Linguistic type:" followed by the code value (with underscores converted to spaces). If the original OLAC `<dc:type>` element has content, simply ignore it. (In all cases to date, it only duplicates the code value; we will advise against using the content.)

_olac:role._ The solution here seems straightforward since DC best practice is for the `<dc:contributor>` or `<dc:creator>` to contain just the name:
 * Discard the role information. However, if the element is `<dc:contributor>` with the role of "author", generate the result as a `<dc:creator>` element.

_olac:language with `<dc:language>`._ Do all of the following which apply:
 * Generate a `<dc:language>` element with the code as its content (unless this would create a duplicate element).
 * If the element has contents, generate a `<dc:language>` element with that content. If the content does not already contain the standard name associated with the code anywhere in the string, prepend the language name followed by semicolon and space.
 * If the element has no contents, generate another `<dc:language>` element with the language name as content.

_olac:language with `<dc:subject>`._ Do all of the following which apply:
 * Generate a `<dc:language>` with the code as its content (unless this would create a duplicate element). (N.B. This is because the DC standard expects ISO 639 codes with the `<dc:language>` element, but not with `<dc:subject>`.)
 * Generate a `<dc:subject>` with the language name as content. Append "language" unless the name of the language already contains that word.
 * If the element has contents, generate another `<dc:subject>` element with that content.

The date-related elements comprise a special case that should be handled by the crosswalk since a generated record should have only one `<dc:date>` element (see, for instance, [http://www.driver-support.eu/documents/DRIVER_Guidelines_v2_Final_2008-11-13.pdf|DRIVER Guidelines]). In the simple DC world, highest preference is given to the date of publication if applicable. Thus generate only one `<dc:date>` element following this guideline:
 * Use the content of the first available element in this order of preference: dc:date, dcterms:issued, dcterms:dateCopyrighted, dcterms:created, dcterms:available, dcterms:dateAccepted, dcterms:dateSubmitted, dcterms:modified, dcterms:valid.

==2. Format for HTML display of OLAC metadata==

We offer an HTML display of OLAC metadata on the _/item/item-id_ page for each record in the aggregated catalog. We also do so on the _/sample/archive-id_ page for each archive. Both pages show a two column table with the metadata element in a narrow left column and the element contents in a wide right column. The problem is standardizing the way we want to display the refinements and encoding schemes of qualified DC. For refinements the two approaches are:
 * The _/item/item-id_ pages show the simple DC equivalent for the element in the left column. If the element is really a dcterms refinement, the element named is added in square brackets to the element content.
 * The _/sample/archive-id_ pages put the actual element name (whether dc or dcterms) in the left column (with spaces inserted for multi-word names).

For encoding schemes the two approaches are:
 * The _/item/item-id_ pages show "`[scheme name = code value]`" prepended to the element content.
 * The _/sample/archive-id_ pages identify the scheme in a parenthesized label appended to the element name in the left column.

Adding refinement information as additional information in the contents does not appear to be the best approach since such information does not appear in the element content in dumbed-down qualified DC. We should therefore put the refinement information in the label (left) column. One thing that is clear from looking at a number of HTML display formats of metadata on web sites is that there is no standard form of display. The two column format is the norm, but sites seem to design the labels with their human readers in mind. There is not a strict adherence to the element labels in the DC standard; rather, labels may be altered to make more sense to the target audience. Thus, we should feel free to update display labels for elements if we want to. Our [[http:_www.language-archives.org/tools/olacdb/olac_schema.sql|database schema]] already includes a display label string for each dc and dcterms element in the ELEMENT_DEFN table. Most of the labels already in the table are fine. The following updates and proposed; then use the labels in our ELEMENT_DEFN table.

|| _Was_ || _Change to_ ||
|| Available || Date Available ||
|| Created || Date Created ||
|| Issued || Date Issued ||
|| Modified || Date Modified ||
|| Valid || Date Valid ||

Again, encoding scheme names do not appear in the element content in dumbed-down qualified; thus we should put it in the label column. I don't recall where I saw the style with parenthesized labels to identify encoding schemes, but that strikes me as the cleanest way to do it. Again, we need to translate them to a user friendly but brief label.

The database schema already lists the dcterms encoding schemes that are recommended by OLAC. Their dcterms names are in the _type_ column. These are appropriate to use as labels except for one case: DCMIType. The element is already Type, thus "Type (DCMIType)" is redundant. "Type (DCMI)" is better.

For the five OLAC encoding schemes, do the following:

|| _Scheme_ || _Label_ || _Examples_ ||
|| olac:language || ISO639 || Language (ISO639), Subject (ISO639) ||
|| olac:linguistic-field || OLAC || Subject (OLAC) ||
|| olac:linguistic-type || OLAC || Type (OLAC) ||
|| olac:role || code value || Contributor (editor) ||
|| olac:discourse-type || Discourse || Type (Discourse) ||

==3. The olac_display format==

The purpose of the _olac_display_ format returned by OLACA is to provide a feed that is optimized for metadata display. It is a bridge between the _olac_ format and the _oai_dc_ format. In the currently implemented _olac_display_ format, the set of elements in a record is identical to the set in the _olac_ format and each element has the same tag name and attributes as the corresponding element in the _olac_ format. The difference is that the content has been augmented to add refinement and encoding scheme information as it will be shown in the _oai_dc_ format.

The concept of a bridge format is still useful, since we will get a more user friendly metadata display on our _/item/item-id_ pages if we make some of the transformations required for the _oai_dc_ format, though we must certainly not make all of them since we have no need to dumb-down the metadata set in our own displays. The following principles will guide the redesign of the _olac_display_ format:
 * The record conforms to the _olac_ metadata schema (that is, it uses the olac:olac wrapper with same set of possible elements and attributes).
 * No elements or data are discarded.
 * No elements are empty; code values that end up in element content for the _oai_dc_ format are moved (without conversion of underscore) to the element content.
 * A single element may be transformed to multiple elements as for the _oai_dc_ format.

The _olac_ to _olac_display_ transformation thus goes part way to _oai_dc_. That transformation is done as follows;
 * _`<dc:type>` with olac:discourse-type._ Move the olac:code value to the element content (discarding any content that may have been there).
 * _`<dc:type>` with olac:linguistic-type._ Move the olac:code value to the element content (discarding any content that may have been there).
 * _`<dc:subject>` with olac:linguistic-field._ First, generate a _`<dc:subject>`_ element that moves the olac:code value to the element content (ignoring any content that may have been there) and drops xml:lang if it is present. Second, if there was original element content, generate a _`<dc:subject>`_ element with that original content and no attributes (except the xml:lang if that is present).
 * _`<dc:subject>` with olac:language._ First, generate a _`<dc:subject>`_ element that moves the olac:code value to the element content (ignoring any content that may have been there) and drops xml:lang if it is present. Second, generate a _`<dc:subject>`_ with the corresponding language name as content and no attributes; append "language" unless the name of the language already contains that word. Third, if there was original element content and it is different from the language name generated in the previous step, generate a _`<dc:subject>`_ element with that original content and no attributes (except the xml:lang if that is present).
 * _`<dc:language>` with olac:language._ First, generate a _`<dc:language>`_ element that moves the olac:code value to the element content (ignoring any content that may have been there) and drops xml:lang if it is present. Second, if the element has contents, generate a `<dc:language>` element with that content (and if the content does not already contain the standard name associated with the code anywhere in the string, prepend the language name followed by semicolon and space). Otherwise, the element has no contents; generate a `<dc:language>` element with the language name as content.

The HTML display of OLAC metadata on the _/item/item-id_ page can then be based on the _olac_display_ format; the element contents are ready for display. The only processing required is to transform the tag to a label as described above in section 2.

The transformation to _oai_dc_ can now be specified as a transformation of the _olac_display_ format:
 * If the element has an xsi:type of olac:linguistic-type, olac:linguistic-field, or olac:discourse-type, change all underscores in the content to spaces.
 * If the element is `<dc:type xsi:type="olac:discourse-type">`, change it to `<dc:description>` and prepend "Discourse type:" to the contents.
 * If the element is `<dc:type xsi:type="olac:linguistic-type">`, prepend "Linguistic type:" to the contents.
 * If the element is `<dc:contributor olac:code="author">`, generate the result as a `<dc:creator>` element.
 * If the element is `<dc:subject xsi:type="olac:language">`, generate a `<dc:language>` element if there is not already one with the same code value; otherwise, generate nothing.
 * Generate only one `<dc:date>` element using the content of the first available element in this order of preference: dc:date, dcterms:issued, dcterms:dateCopyrighted, dcterms:created, dcterms:available, dcterms:dateAccepted, dcterms:dateSubmitted, dcterms:modified, dcterms:valid. Discard all other date-related elements.
 * If the element is in the dcterms namespace, output it as its more generic dc equivalent.
 * Discard all attributes.